{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyShell","text":""},{"location":"#what-is-pyshell","title":"What is PyShell?","text":"<p>PyShell is a Python library designed to help developers create shell scripts. At its most basic, PyShell can be thought of as a wrapper around <code>subprocess.run()</code> that allows IDEs to display autocompletion help for commands. However, PyShell is much more than a basic wrapper and offers many features that greatly improve development workflows.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross platform support</li> </ul> <p>PyShell scripts are standard python scripts and can be run on any platform that Python supports. Built-in PyShell modules are designed to be cross platform, so PyShell-based scripts generally do not need to branch by OS. By writing scripts using PyShell, you'll no longer need to write bash and batch scripts that are functionally identical.</p> <ul> <li>Command autocompletion</li> </ul> <p>The built-in PyShell modules allow shell commands and external executables to be invoked as Python methods. This allows IDEs to present information about the parameters that the method accepts instead of forcing developers to try and remember exactly what flag it was that does what you need.</p> <ul> <li>Automatic logging to files</li> </ul> <p>Using PyShell's built in logger classes, you can choose how you want to log your script's output. For example, you can configure PyShell to tee all output from commands executed by your script to a single file, or you can choose to write each command's output to a different file. Logging configuration is handled when you initialize a <code>PyShell</code> class instance and does not need to be handled on a per-command basis.</p> <ul> <li>Error handling</li> </ul> <p>PyShell gives scripts a lot of control over how they want to handle errors. Basic scripts may simply want to abort script execution upon encountering an error, while other scripts may want to continue executing certain commands such as cleanup commands. PyShell provides built-in classes that make it easy to implement proper error handling in scripts.</p> <ul> <li>Automatic validation</li> </ul> <p>It's all to easy to write scripts that assume certain conditions are true and end up erroring out far away from where the invalid assumption is located. PyShell commands automatically validate their input and any external state required to run the command when the command instance is constructed, allowing errors to be detected as early as possible.</p> <ul> <li>Docker container support</li> </ul> <p>Info</p> <p>This feature is in development and will be added soon!</p> <p>PyShell instances can be configured to target a docker container instead of running commands on the host system. This means that PyShell scripts can execute commands on the host system as well as within a docker container, and all from a single script.</p>"},{"location":"motivation/","title":"Motivation","text":""},{"location":"motivation/#shell-scripts","title":"Shell Scripts","text":"<p>PyShell was born out of a desire to unify platform specific shell scripts into a single script with a uniform feature set regardless of OS. For example, bash offers the <code>set -e</code> command to abort a script as soon as a script command fails: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\nls /foo # &lt;&lt;&lt; The script will exit here if /foo doesn't exist\necho \"This will not be printed.\"\n</code></pre></p> <p>But Batch does not offer an equivalent feature, instead requiring developers to write multiple extra lines to accomplish the same functionality: error.bat<pre><code>dir \"C:\\foo\"\nif errorlevel 1 (\nexit /b 1\n)\n</code></pre></p> <p>Using two different shell scripting languages also requires developers to be familiar with both languages. Even so, it's extremely easy to inadvertently introduce small differences in behavior, such as when using the <code>echo</code> command: echo.sh<pre><code>#!/usr/bin/env bash\necho \"foo\"\n# Output:\nfoo\n</code></pre> echo.bat<pre><code>@echo off\necho \"foo\"\nREM Output:\n\"foo\"\n</code></pre></p> <p>Standard out-of-the-box python fares better in regards to standardization between platforms, but suffers when running commands: cmake.sh<pre><code>#!/usr/bin/env bash\nset -e\n\n# Run CMake's configure step\ncmake -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\n\n# Build the project\ncmake --build _build --target install\n</code></pre> cmake.bat<pre><code>@echo off\n\nREM Run CMake's configure step\ncmake.exe -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\nif errorlevel 1 (\nexit /b\n)\nREM Build the project\ncmake.exe --build _build --target install\nif errorlevel 1 (\nexit /b\n)\n</code></pre> cmake.py<pre><code>#!/usr/bin/env python3\nimport subprocess\n# Run CMake's configure step\nsubprocess.run(\n[\n\"cmake\",\n\"-S\",\n\".\",\n\"-B\",\n\"_build\",\n\"-DCMAKE_BUILD_TYPE=Debug\",\n\"-DCMAKE_INSTALL_PREFIX=_out\"\n],\ncheck=True\n)\n# Run CMake's build step\nsubprocess.run(\n[\"cmake\", \"--build\", \"_build\", \"--target\", \"install\"],\ncheck=True\n)\n</code></pre></p> <p>This is where PyShell and its built in modules come into play. Using PyShell's CMake module, that <code>cmake.py</code> script could be written this way instead: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Named function arguments shown for clarity only\nCMake.configure(\nsource=\".\",\nbuild=\"_build\",\ninstall=\"_out\",\nbuild_type=ECMakeBuildType.Debug,\n)\nCMake.build(\nbuild=\"_build\",\ntarget=\"install\"\n)\n</code></pre> Without the named function arguments, the script is almost on par with the bash script: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Run CMake's configure step\nCMake.configure(\".\", \"_build\", \"_out\", ECMakeBuildType.Debug)\n# Run CMake's build step\nCMake.build(\"_build\", \"install\")\n</code></pre></p> <p>Warning</p> <p>PyShell's CMake module has not been released yet. You may also want to consider making use of PyShell's sibling project, PyMake! PyMake is to CMake as PyShell is to shell scripts.</p> <p>Unlike the previous python script, the PyShell-based script is much more strongly typed. When writing the PyShell script, developers don't have to remember the exact flags that CMake requires for setting its source directory or build type since IDEs can display the method's parameters to developers. PyShell will also do additional validation when the script runs, such as verifying that the CMake executable can be found.</p>"},{"location":"motivation/#error-handling","title":"Error Handling","text":"<p>Though PyShell's foundation was rooted in using Python for shell scripts, PyShell has grown into much more. PyShell shines particularly bright when it comes to error handling, where PyShell scripts have significant improvements over their batch/bash counterparts.</p> <p>For example, consider this bash script: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nls /foo/bar\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The output of that script is: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\n</code></pre></p> <p>This script is just a toy script, but imagine if the script's cleanup command had to run something more important. What if the cleanup command was one that corrected file permissions on a CI/CD system, and now every subsequent CI/CD run on that machine will now fail? That's obviously no good, so the script clearly must be adjusted to handle that. There's more than one way to go about this, such as: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nif ! ls /foo/bar; then\necho \"error\"\nfi\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The updated script's output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nerror\nafter failed command\nperform cleanup\n</code></pre></p> <p>This is better, but now there's a different problem. If the \"after failed command\" command is only valid to be executed if the failing command finished successfully, then now the script will now terminate on that line instead. That command could be moved into the if statement, but a real script may have many lines between the two commands or many dependent commands. Alternatively, the cleanup code could be moved into its own function: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\ncleanup() {\necho \"perform cleanup\"\nexit $1\n}\necho \"before failed command\"\nls /foo/bar || cleanup 1\necho \"after failed command\" || cleanup 1\ncleanup 0\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nperform cleanup\n</code></pre></p> <p>That's a significant improvement, but PyShell can do even better: error.py<pre><code>#!/usr/bin/env python3\nfrom pyshell import PyShell, KeepGoing, PermitCleanup, CommandFlags\nfrom pyshell.modules import Shell\npyshell = PyShell(\nexecutor=PermitCleanup(),\nerror_handler=KeepGoing()\n)\n# No commands have failed, so this command will be run\nShell.echo(\"before failed command\")\n# This command will fail, but the error handler will ignore it because the\n#   error handler is set to `KeepGoing`\nShell.ls(\"/foo/bar\")\n# This command won't run because it's a standard command\nShell.echo(\"after failed command\")\n# This command will run because it's a cleanup command\nShell.echo(\"perform cleanup\", cmd_flags=CommandFlags.CLEANUP)\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./sample.py\nbefore failed command\n/usr/bin/ls: cannot access '/foo/bar': No such file or directory\nCommand '/usr/bin/ls' failed with exit code 2.\nNote: Full command was '/usr/bin/ls /foo/bar'.\nperform cleanup\n</code></pre></p> <p>This example introduces a new PyShell concept, the executor. This is a component that decides whether a command is allowed to execute. In this example, the <code>PermitCleanup</code> executor is used along with the <code>KeepGoing</code> error handler. This is necessary to avoid stopping the script immediately upon a command failing, which is what would happen if the script had used the <code>AbortOnFailure</code> error handler. The <code>KeepGoing</code> error handler also isn't usable on its own in this scenario, as otherwise it would allow the \"after failed command\" echo command to be executed.</p> <p>Instead, the combination of the <code>PermitCleanup</code> executor and the <code>KeepGoing</code> error handler ensures that all commands after the failed command do not execute... except cleanup commands. By using these two PyShell components, the script can be written with a linear structure that does not require the reader to jump to the cleanup method to discover what the script runs.</p>"},{"location":"motivation/#logging","title":"Logging","text":"<p>PyShell was designed with a heavy emphasis on logging, resulting in a number of features that assist developers in processing log files generated by a script. PyShell defaults to only writing information to the console, but its behavior can be easily adjusted to also write to log files on disk while also printing to the console. For example, PyShell offers the <code>SingleFileLogger</code> and <code>MultiFileLogger</code> classes, which are used in the \"Hello World\" sample script: hello_world.py<pre><code>#!/usr/bin/env python3\nimport argparse\nfrom pyshell import PyShell, NullFileLogger, SingleFileLogger, MultiFileLogger\nfrom pyshell.modules import Shell\n# Decide whether to log to a single file or multiple files\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--log\", choices=[\"single\", \"multi\"], default=None)\nargs = parser.parse_args()\nif args.log == \"single\":\nlogger = SingleFileLogger(\"hello_world.log\")\nelif args.log == \"multi\":\nlogger = MultiFileLogger(\n\".logs\",\nprint_cmd_header=True,\nprint_cmd_footer=True\n)\nelse:\nlogger = NullFileLogger()\n# Initialize a PyShell instance for running commands\n# PyShell commands that don't explicitly specify a PyShell instance to use\n#   will use the default instance.\npyshell = PyShell(logger=logger)\n# Run some commands\nShell.echo(\"Hello, world!\")\nShell.echo(\"Hello world again!\")\nShell.echo(\"Howdy y'all!\")\n</code></pre></p> <p>When the <code>NullFileLogger</code> class is used, the only output from the script is to the console: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py Hello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 12\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:55 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\n</code></pre></p> <p>If the <code>--log single</code> flag is provided, output will be written to both the console and a log file on disk: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py --log single\nHello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 16\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:56 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\n-rw-r--r-- 1 pyshell pyshell   49 Feb 27 02:56 hello_world.log\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ cat hello_world.log\nHello, world!\nHello world again!\nHowdy y'all!\n</code></pre></p> <p>Alternatively, if <code>--log multi</code> is used, each command's output is written to its own file: <pre><code>pyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ./hello_world.py --log multi\nHello, world!\nHello world again!\nHowdy y'all!\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll\ntotal 16\ndrwxr-xr-x 3 pyshell pyshell 4096 Feb 27 02:57 ./\ndrwxrwxr-x 3 pyshell pyshell 4096 Feb 23 20:52 ../\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:57 .logs/\n-rwxr-xr-x 1 pyshell pyshell  903 Feb 27 02:54 hello_world.py*\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ ll .logs\ntotal 20\ndrwxr-xr-x 2 pyshell pyshell 4096 Feb 27 02:57 ./\ndrwxr-xr-x 3 pyshell pyshell 4096 Feb 27 02:57 ../\n-rw-r--r-- 1 pyshell pyshell  306 Feb 27 02:57 1-echo.log\n-rw-r--r-- 1 pyshell pyshell  321 Feb 27 02:57 2-echo.log\n-rw-r--r-- 1 pyshell pyshell  303 Feb 27 02:57 3-echo.log\npyshell@85afc3805162:/workspaces/PyShell/samples/1-hello-world$ cat .logs/1-echo.log [PyShell] Running command: /usr/bin/echo Hello, world!\n[PyShell] cwd: /workspaces/PyShell/samples/1-hello-world\n[PyShell] Command output:\nHello, world!\n[PyShell] Executed command: /usr/bin/echo Hello, world!\n[PyShell] cwd: /workspaces/PyShell/samples/1-hello-world\n[PyShell] Command exited with code 0.\n</code></pre></p> <p>Visible in the multi-file logger example is PyShell's optional header and footer sections. These sections are enabled by passing these arguments to the multi-file logger's constructor: <pre><code>logger = MultiFileLogger(\n\".logs\",\nprint_cmd_header=True, # &lt;&lt;&lt;\nprint_cmd_footer=True  # &lt;&lt;&lt;\n)\n</code></pre></p> <p>Info</p> <p>These parameters are also supported by the <code>SingleFileLogger</code> class's constructor.</p> <p>PyShell also allows a scanner class to be attached to commands, which enables PyShell to output extra information to help developers. This is particularly helpful when dealing with long log files that would otherwise require developers to scroll through the log to find what they're looking for.</p> <p>For example, PyShell's <code>generate_docs.py</code> script invokes Doxygen and generates a ~500 line file. Should the command fail, such as due to a parameter lacking documentation, the <code>generate_docs.py</code> script will stop and report an error. A developer would then need to scroll through the log file generated for the Doxygen command, find the error message from Doxygen, then open the file and fix the issue. With PyShell's Doxygen scanner however, the bottom of the log file contains all the information necessary to fix the issue: doxygen.log<pre><code>Patching output file 34/36\nPatching output file 35/36\nPatching output file 36/36\nlookup cache used 645/65536 hits=1314 misses=768\nfinished...\nExiting...\n[PyShell] Scanner output:\n[PyShell] Missing parameter documentation for:\n[PyShell]   File: /workspaces/PyShell/source/pyshell/core/command_metadata.py:15\n[PyShell]   Method: pyshell.core.command_metadata.CommandMetadata.__init__(self, str command, Sequence[str] args, CommandFlags flags=CommandFlags.STANDARD, Optional[IScanner] scanner=None)\n[PyShell]   Parameter: scanner\n[PyShell] Missing parameter documentation for:\n[PyShell]   File: /workspaces/PyShell/source/pyshell/doxygen/doxygen_scanner.py:81\n[PyShell]   Method: pyshell.doxygen.doxygen_scanner.DoxygenScanner._generate_missing_parameter_entry(self, CommandResult result, str line, List[str] next_lines, int line_number)\n[PyShell]   Parameter: result\n[PyShell] Executed command: /usr/bin/doxygen /workspaces/PyShell/doxygen/doxyfile\n[PyShell] cwd: /workspaces/PyShell\n[PyShell] Command exited with code 1.\n</code></pre></p> <p>Though scanners are nothing complex, their addition to PyShell is a solid quality of life addition for developers.</p>"}]}