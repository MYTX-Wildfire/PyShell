{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyShell","text":""},{"location":"#what-is-pyshell","title":"What is PyShell?","text":"<p>PyShell is a Python library designed to help developers create shell scripts. At its most basic, PyShell can be thought of as a wrapper around <code>subprocess.run()</code> that allows IDEs to display autocompletion help for commands. However, PyShell is much more than a basic wrapper and offers many features that greatly improve development workflows.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross platform support</li> </ul> <p>PyShell scripts are standard python scripts and can be run on any platform that Python supports. Built-in PyShell modules are designed to be cross platform, so PyShell-based scripts generally do not need to branch by OS. By writing scripts using PyShell, you'll no longer need to write bash and batch scripts that are functionally identical.</p> <ul> <li>Command autocompletion</li> </ul> <p>The built-in PyShell modules allow shell commands and external executables to be invoked as Python methods. This allows IDEs to present information about the parameters that the method accepts instead of forcing developers to try and remember exactly what flag it was that does what you need.</p> <ul> <li>Automatic logging to files</li> </ul> <p>Using PyShell's built in logger classes, you can choose how you want to log your script's output. For example, you can configure PyShell to tee all output from commands executed by your script to a single file, or you can choose to write each command's output to a different file. Logging configuration is handled when you initialize a <code>PyShell</code> class instance and does not need to be handled on a per-command basis.</p> <ul> <li>Error handling</li> </ul> <p>PyShell gives scripts a lot of control over how they want to handle errors. Basic scripts may simply want to abort script execution upon encountering an error, while other scripts may want to continue executing certain commands such as cleanup commands. PyShell provides built-in classes that make it easy to implement proper error handling in scripts.</p> <ul> <li>Automatic validation</li> </ul> <p>It's all to easy to write scripts that assume certain conditions are true and end up erroring out far away from where the invalid assumption is located. PyShell commands automatically validate their input and any external state required to run the command when the command instance is constructed, allowing errors to be detected as early as possible.</p> <ul> <li>Docker container support</li> </ul> <p>Info</p> <p>This feature is in development and will be added soon!</p> <p>PyShell instances can be configured to target a docker container instead of running commands on the host system. This means that PyShell scripts can execute commands on the host system as well as within a docker container, and all from a single script.</p>"},{"location":"motivation/","title":"Motivation","text":""},{"location":"motivation/#shell-scripts","title":"Shell Scripts","text":"<p>PyShell was born out of a desire to unify platform specific shell scripts into a single script that would provide a uniform feature set regardless of the OS a script is executing on. For example, bash offers the <code>set -e</code> command to abort a script as soon as a script command fails: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\nls /foo # &lt;&lt;&lt; The script will exit here if /foo doesn't exist\necho \"This will not be printed.\"\n</code></pre></p> <p>Batch does not offer an equivalent feature, instead requiring developers to write multiple extra lines to accomplish the same functionality: error.bat<pre><code>dir \"C:\\foo\"\nif errorlevel 1 (\nexit /b 1\n)\n</code></pre></p> <p>Using two different shell scripting languages also requires developers to be familiar with both languages. Even so, it's still extremely easy to inadvertently introduce small differences in behavior, such as when using the <code>echo</code> command: echo.sh<pre><code>#!/usr/bin/env bash\necho \"foo\"\n# Output:\nfoo\n</code></pre> echo.bat<pre><code>@echo off\necho \"foo\"\nREM Output:\n\"foo\"\n</code></pre></p> <p>Standard out of the box python fares better in regards to standardization between platforms, but suffers when it comes to running commands: cmake.sh<pre><code>#!/usr/bin/env bash\nset -e\n\n# Run CMake's configure step\ncmake -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\n\n# Build the project\ncmake --build _build --target install\n</code></pre> cmake.bat<pre><code>@echo off\n\nREM Run CMake's configure step\ncmake.exe -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\nif errorlevel 1 (\nexit /b\n)\nREM Build the project\ncmake.exe --build _build --target install\nif errorlevel 1 (\nexit /b\n)\n</code></pre> cmake.py<pre><code>#!/usr/bin/env python3\nimport subprocess\n# Run CMake's configure step\nsubprocess.run(\n[\n\"cmake\",\n\"-S\",\n\".\",\n\"-B\",\n\"_build\",\n\"-DCMAKE_BUILD_TYPE=Debug\",\n\"-DCMAKE_INSTALL_PREFIX=_out\"\n],\ncheck=True\n)\n# Run CMake's build step\nsubprocess.run(\n[\"cmake\", \"--build\", \"_build\", \"--target\", \"install\"],\ncheck=True\n)\n</code></pre></p> <p>This is where PyShell and its built in modules come into play. Using PyShell's CMake module, that <code>cmake.py</code> script could be written this way instead: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Named function arguments shown for clarity only\nCMake.configure(\nsource=\".\",\nbuild=\"_build\",\ninstall=\"_out\",\nbuild_type=ECMakeBuildType.Debug,\n)\nCMake.build(\nbuild=\"_build\",\ntarget=\"install\"\n)\n</code></pre> Without the named function arguments, the script is almost on par with the bash script: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Run CMake's configure step\nCMake.configure(\".\", \"_build\", \"_out\", ECMakeBuildType.Debug)\n# Run CMake's build step\nCMake.build(\"_build\", \"install\")\n</code></pre></p> <p>Warning</p> <p>PyShell's CMake module has not been released yet. You may also want to consider making use of PyShell's sibling project, PyMake! PyMake is to CMake as PyShell is to shell scripts.</p> <p>Unlike the previous python script, the PyShell-based script is much more strongly typed. When writing the PyShell script, developers don't have to remember the exact flags that CMake requires for setting its source directory or build type since IDEs can display the method's parameters to developers. PyShell will also do additional validation when the script runs, such as verifying that the CMake executable can be found.</p>"},{"location":"motivation/#error-handling","title":"Error Handling","text":"<p>Though PyShell's foundation was rooted in using Python for shell scripts, PyShell has grown into much more. PyShell shines particularly bright when it comes to error handling, where PyShell scripts have significant improvements over their batch/bash counterparts.</p> <p>For example, consider this bash script: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nls /foo/bar\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The output of that script is: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\n</code></pre></p> <p>This script is just a toy script, but imagine if the script's cleanup command had to run something more important. What if the cleanup command was one that modified file permissions on a CI/CD system, and now every subsequent CI/CD run on that machine will now fail? That's obviously no good, so the script clearly must be adjusted to handle that. There's more than one way to go about this, such as: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\necho \"before failed command\"\nif ! ls /foo/bar; then\necho \"error\"\nfi\necho \"after failed command\"\necho \"perform cleanup\"\n</code></pre></p> <p>The updated script's output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nerror\nafter failed command\nperform cleanup\n</code></pre></p> <p>This is better, but now there's a different problem. If the \"after failed command\" command is only valid to be executed if our failing command finished successfully, then now the script will now terminate on that line instead. That command could be moved into the if statement, but a real script may have many lines between the two commands or many dependent commands. Alternatively, the cleanup code could be moved into its own function: error.sh<pre><code>#!/usr/bin/env bash\nset -e\n\ncleanup() {\necho \"perform cleanup\"\nexit $1\n}\necho \"before failed command\"\nls /foo/bar || cleanup 1\necho \"after failed command\" || cleanup 1\ncleanup 0\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./error.sh\nbefore failed command\nls: cannot access '/foo/bar': No such file or directory\nperform cleanup\n</code></pre></p> <p>That's a significant improvement, but PyShell can do even better: error.py<pre><code>#!/usr/bin/env python3\nfrom pyshell import PyShell, KeepGoing, PermitCleanup, CommandFlags\nfrom pyshell.modules import Shell\npyshell = PyShell(\nexecutor=PermitCleanup(),\nerror_handler=KeepGoing()\n)\n# No commands have failed, so this command will be run\nShell.echo(\"before failed command\")\n# This command will fail, but the error handler will ignore it because the\n#   error handler is set to `KeepGoing`\nShell.ls(\"/foo/bar\")\n# This command won't run because it's a standard command\nShell.echo(\"after failed command\")\n# This command will run because it's a cleanup command\nShell.echo(\"perform cleanup\", cmd_flags=CommandFlags.CLEANUP)\n</code></pre></p> <p>Output: <pre><code>pyshell@85afc3805162:/workspaces/PyShell$ ./sample.py\nbefore failed command\n/usr/bin/ls: cannot access '/foo/bar': No such file or directory\nCommand '/usr/bin/ls' failed with exit code 2.\nNote: Full command was '/usr/bin/ls /foo/bar'.\nperform cleanup\n</code></pre></p> <p>This example introduces a new PyShell concept, the executor. This is a component that decides whether a command is allowed to execute. In this example, the <code>PermitCleanup</code> executor is used along with the <code>KeepGoing</code> error handler. This is necessary to avoid stopping the script immediately, which is what would happen if the script had used the <code>AbortOnFailure</code> error handler. The <code>KeepGoing</code> error handler also isn't usable in this scenario on its own, as otherwise it would allow the \"after failed command\" echo command to be executed.</p> <p>Instead, the combination of the <code>PermitCleanup</code> executor and the <code>KeepGoing</code> error handler ensures that all commands after the failed command do not execute... except cleanup commands. By using these two PyShell components, the script can be written with a linear structure that does not require the reader to jump to the cleanup method to discover what the script runs.</p>"}]}