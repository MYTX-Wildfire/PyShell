{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyShell","text":""},{"location":"#what-is-pyshell","title":"What is PyShell?","text":"<p>PyShell is a Python library designed to help developers create shell scripts. At its most basic, PyShell can be thought of as a wrapper around <code>subprocess.run()</code> that allows IDEs to display autocompletion help for commands. However, PyShell is much more than a basic wrapper and offers many features that greatly improve development workflows.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross platform support</li> </ul> <p>PyShell scripts are standard python scripts and can be run on any platform that Python supports. Built-in PyShell modules are designed to be cross platform, so PyShell-based scripts generally do not need to branch by OS. By writing scripts using PyShell, you'll no longer need to write bash and batch scripts that are functionally identical.</p> <ul> <li>Command autocompletion</li> </ul> <p>The built-in PyShell modules allow shell commands and external executables to be invoked as Python methods. This allows IDEs to present information about the parameters that the method accepts instead of forcing developers to try and remember exactly what flag it was that does what you need.</p> <ul> <li>Automatic logging to files</li> </ul> <p>Using PyShell's built in logger classes, you can choose how you want to log your script's output. For example, you can configure PyShell to tee all output from commands executed by your script to a single file, or you can choose to write each command's output to a different file. Logging configuration is handled when you initialize a <code>PyShell</code> class instance and does not need to be handled on a per-command basis.</p> <ul> <li>Error handling</li> </ul> <p>PyShell gives scripts a lot of control over how they want to handle errors. Basic scripts may simply want to abort script execution upon encountering an error, while other scripts may want to continue executing certain commands such as cleanup commands. PyShell provides built-in classes that make it easy to implement proper error handling in scripts.</p> <ul> <li>Automatic validation</li> </ul> <p>It's all to easy to write scripts that assume certain conditions are true and end up erroring out far away from where the invalid assumption is located. PyShell commands automatically validate their input and any external state required to run the command when the command instance is constructed, allowing errors to be detected as early as possible.</p> <ul> <li>Docker container support</li> </ul> <p>Info</p> <p>This feature is in development and will be added soon!</p> <p>PyShell instances can be configured to target a docker container instead of running commands on the host system. This means that PyShell scripts can execute commands on the host system as well as within a docker container, and all from a single script.</p>"},{"location":"motivation/","title":"Motivation","text":"<p>PyShell was born out of a desire to unify platform specific shell scripts into a single script that would provide a uniform feature set regardless of the OS a script is executing on. For example, bash offers the <code>set -e</code> command to abort a script as soon as a script command fails: <pre><code>#!/usr/bin/env bash\nset -e\n\nls /foo # &lt;&lt;&lt; The script will exit here if /foo doesn't exist\necho \"This will not be printed.\"\n</code></pre></p> <p>Batch does not offer an equivalent feature, instead requiring developers to write multiple extra lines to accomplish the same functionality: <pre><code>dir \"C:\\foo\"\nif errorlevel 1 (\nexit /b 1\n)\n</code></pre></p> <p>Using two different shell scripting languages also requires developers to be familiar with both languages. Even so, it's still extremely easy to inadvertently introduce small differences in behavior, such as when using the <code>echo</code> command: echo.sh<pre><code>#!/usr/bin/env bash\necho \"foo\"\n# Output:\nfoo\n</code></pre> echo.bat<pre><code>@echo off\necho \"foo\"\nREM Output:\n\"foo\"\n</code></pre></p> <p>Standard out of the box python fares better in regards to standardization between platforms, but suffers when it comes to running commands: cmake.sh<pre><code>#!/usr/bin/env bash\nset -e\n\n# Run CMake's configure step\ncmake -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\n\n# Build the project\ncmake --build _build --target install\n</code></pre> cmake.bat<pre><code>@echo off\n\nREM Run CMake's configure step\ncmake.exe -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=_out\nif errorlevel 1 (\nexit /b\n)\nREM Build the project\ncmake.exe --build _build --target install\nif errorlevel 1 (\nexit /b\n)\n</code></pre> cmake.py<pre><code>#!/usr/bin/env python3\nimport subprocess\n# Run CMake's configure step\nsubprocess.run(\n[\n\"cmake\",\n\"-S\",\n\".\",\n\"-B\",\n\"_build\",\n\"-DCMAKE_BUILD_TYPE=Debug\",\n\"-DCMAKE_INSTALL_PREFIX=_out\"\n],\ncheck=True\n)\n# Run CMake's build step\nsubprocess.run(\n[\"cmake\", \"--build\", \"_build\", \"--target\", \"install\"],\ncheck=True\n)\n</code></pre></p> <p>This is where PyShell and its built in modules come into play. Using PyShell's CMake module, that <code>cmake.py</code> script could be written this way instead: cmake.py<pre><code>from pyshell import PyShell, AbortOnFailure\nfrom pyshell.modules import CMake, ECMakeBuildType\npyshell = PyShell(error_handler=AbortOnFailure())\n# Named function arguments shown for clarity only\nCMake.configure(\nsource=\".\",\nbuild=\"_build\",\ninstall=\"_out\",\nbuild_type=ECMakeBuildType.Debug,\n)\nCMake.build(\nbuild=\"_build\",\ntarget=\"install\"\n)\n</code></pre></p> <p>Warning</p> <p>PyShell's CMake module has not been released yet. Also, consider making use of PyShell's sibling project, PyMake! PyMake is to CMake as PyShell is to shell scripts.</p> <p>Unlike the previous python script, the PyShell-based script is much more strongly typed. When writing the PyShell script, developers don't have to remember the exact flags that CMake requires for setting its source directory or build type since IDEs can display the method's parameters to developers. PyShell will also do additional validation when the script runs, such as verifying that the CMake executable can be found.</p>"}]}